<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Homecoming</title>
<style>
html, body {
  margin: 0;
  padding: 0;
  height: 100%;
  width: 100%;
  background: #000;
  font-family: Arial, sans-serif;
  overflow: hidden;
  display: flex;
  justify-content: center;
  align-items: center;
}

.container {
  position: relative;
  width: 100%;
  height: 100%;
}

/* Responsive timer font size */
.timer {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  display: flex;
  flex-direction: row;
  gap: 2vw;
  font-size: clamp(40px, 10vw, 120px);
  color: #fff;
  opacity: 0; /* hidden by default */
  transition: opacity 0.3s ease;
}

.time-section {
  display: flex;
  align-items: baseline;
  gap: 0.2em;
}

.digit {
  display: inline-block;
  width: 2ch;
  text-align: right;
}

.label {
  font-size: 0.25em;
  color: #aaa;
}

/* Portrait / small screens: vertical stack and scale font to fit */
@media screen and (max-width: 600px), screen and (orientation: portrait) {
  .timer {
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 1vh; 
    font-size: clamp(30px, 12vh, 80px);
    height: 100%;
  }

  .time-section {
    flex-direction: row;
    align-items: center;
    gap: 0.2em;
  }

  .digit {
    width: auto;
    text-align: center;
  }
}

canvas {
  position: absolute;
  top: 0;
  left: 0;
  display: block;
  width: 100%;
  height: 100%;
}
</style>
</head>
<body>

<div class="container">
  <div class="timer" id="countdown">
    <div class="time-section" id="days">
      <div class="digit">00</div><div class="label">d</div>
    </div>
    <div class="time-section" id="hours">
      <div class="digit">00</div><div class="label">h</div>
    </div>
    <div class="time-section" id="minutes">
      <div class="digit">00</div><div class="label">m</div>
    </div>
    <div class="time-section" id="seconds">
      <div class="digit">00</div><div class="label">s</div>
    </div>
  </div>
  <canvas id="stars"></canvas>
</div>

<script>
// Countdown logic
function pad(num) { return num.toString().padStart(2, '0'); }

const targetDate = new Date('2025-10-16T16:00:00-05:00');
let timerInterval;

function updateTimer() {
  const now = new Date();
  let diff = targetDate - now;
  if (diff <= 0) return true;

  const days = Math.floor(diff / (1000*60*60*24));
  diff -= days*(1000*60*60*24);
  const hours = Math.floor(diff/(1000*60*60));
  diff -= hours*(1000*60*60);
  const minutes = Math.floor(diff/(1000*60));
  diff -= minutes*(1000*60);
  const seconds = Math.floor(diff/1000);

  const values = {days, hours, minutes, seconds};
  for (const [key, value] of Object.entries(values)){
    document.getElementById(key).querySelector('.digit').textContent = pad(value);
  }
  return false;
}

function startCountdown(){
  return new Promise(resolve=>{
    timerInterval = setInterval(()=>{
      if(updateTimer()){
        clearInterval(timerInterval);
        const countdownEl = document.getElementById('countdown');
        countdownEl.style.opacity = 0;
        setTimeout(resolve, 300); 
      }
    },1000);
    updateTimer();
  });
}

// Canvas & stars
const canvas = document.getElementById('stars');
const ctx = canvas.getContext('2d');
let width = canvas.width = window.innerWidth;
let height = canvas.height = window.innerHeight;

// Background stars
class BGStar {
  constructor(){ this.reset(); }
  reset(){
    this.x=Math.random()*width;
    this.y=Math.random()*height;
    this.size=Math.random()*1.5;
    this.alpha=0;
    this.life=6000 + Math.random()*6000;
    this.visible=false;
  }
  spawn(now){ this.birth=now; this.visible=true; }
  update(now){
    if(!this.visible) return;
    let age=(now-this.birth)%this.life;
    this.alpha=Math.sin((age/this.life)*Math.PI);
  }
  draw(){
    if(!this.visible) return;
    ctx.beginPath();
    ctx.arc(this.x,this.y,this.size,0,Math.PI*2);
    ctx.fillStyle=`rgba(255,255,255,${this.alpha})`;
    ctx.shadowBlur=1.5; ctx.shadowColor='white';
    ctx.fill(); ctx.shadowBlur=0;
  }
}

const totalBGStars = 700;
const bgStars = [];
for(let i=0;i<totalBGStars;i++) bgStars.push(new BGStar());
let bgProgressStart = null;

// JL positions
const offCanvas = document.createElement('canvas');
const offCtx = offCanvas.getContext('2d');
offCanvas.width = width; offCanvas.height = height;
const fontSize = Math.min(width,height)/3;
offCtx.fillStyle='white';
offCtx.font = `${fontSize}px sans-serif`;
offCtx.textAlign='center';
offCtx.textBaseline='middle';
offCtx.fillText('J+L', width/2, height/2);

const imageData = offCtx.getImageData(0,0,width,height).data;
const jlPositions = [];
for(let y=0;y<height;y+=5){
  for(let x=0;x<width;x+=5){
    if(imageData[(y*width+x)*4+3]>128) jlPositions.push({x,y});
  }
}

class JLStar{
  constructor(x,y){ this.x=x; this.y=y; this.size=Math.random()*1+0.5; this.alpha=0; this.visible=false; this.birth=0; this.life=4000; }
  reset(now,life){ this.birth=now; this.life=life; this.visible=true; }
  update(now){ if(!this.visible) return; let age=now-this.birth; if(age>this.life){ this.visible=false; return; } let t=age/this.life; this.alpha=Math.sin(t*Math.PI);}
  draw(){ if(!this.visible) return; ctx.beginPath(); ctx.arc(this.x,this.y,this.size,0,Math.PI*2); ctx.fillStyle=`rgba(255,255,255,${this.alpha})`; ctx.shadowBlur=2; ctx.shadowColor='white'; ctx.fill(); ctx.shadowBlur=0; }
}
const jlStars = jlPositions.map(pos=>new JLStar(pos.x,pos.y));

let jlProgressStart = null;
const jlEmergenceDuration = 30*1000;
const skyBuildDuration = 30*1000;

function animate(timestamp){
  if(!jlProgressStart) jlProgressStart = timestamp;
  if(!bgProgressStart) bgProgressStart = timestamp;

  ctx.clearRect(0,0,width,height);

  const elapsed = timestamp - bgProgressStart;
  let skyFraction = Math.min(elapsed/skyBuildDuration,1);
  skyFraction = Math.pow(skyFraction, 3); 

  const starsToSpawn = Math.ceil(totalBGStars * 0.02 * skyFraction);
  let spawned = 0;
  for(const star of bgStars){
    if(!star.visible && spawned < starsToSpawn){
      star.spawn(timestamp);
      spawned++;
    }
  }
  bgStars.forEach(star=>{star.update(timestamp); star.draw();});

  if(elapsed > skyBuildDuration){
    const jlElapsed = timestamp - (jlProgressStart + skyBuildDuration);
    const jlProgress = Math.min(jlElapsed / jlEmergenceDuration, 1);
    const baseDensity = 0.001;
    const densityFactor = baseDensity + baseDensity * 8 * jlProgress;

    jlStars.forEach(star=>{
      if(!star.visible && Math.random() < densityFactor){
        star.reset(timestamp, 6000 + Math.random()*6000);
      }
      star.update(timestamp);
      star.draw();
    });
  }
  requestAnimationFrame(animate);
}

async function main(){
  const now = new Date();
  const countdownEl = document.getElementById('countdown');

  if (targetDate - now > 0) {
    // Show countdown only if future
    countdownEl.style.opacity = 1;
    await startCountdown();
  }

  // Start animation
  jlProgressStart = null;
  bgProgressStart = null;
  requestAnimationFrame(animate);
}

// Resize canvas
window.addEventListener('resize',()=>{
  width = canvas.width = window.innerWidth;
  height = canvas.height = window.innerHeight;
});

main();
</script>
</body>
</html>
